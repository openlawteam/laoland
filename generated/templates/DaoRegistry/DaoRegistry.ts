// THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.

import {
  ethereum,
  JSONValue,
  TypedMap,
  Entity,
  Bytes,
  Address,
  BigInt
} from "@graphprotocol/graph-ts";

export class AdapterAdded extends ethereum.Event {
  get params(): AdapterAdded__Params {
    return new AdapterAdded__Params(this);
  }
}

export class AdapterAdded__Params {
  _event: AdapterAdded;

  constructor(event: AdapterAdded) {
    this._event = event;
  }

  get adapterId(): Bytes {
    return this._event.parameters[0].value.toBytes();
  }

  get adapterAddress(): Address {
    return this._event.parameters[1].value.toAddress();
  }

  get flags(): BigInt {
    return this._event.parameters[2].value.toBigInt();
  }
}

export class AdapterRemoved extends ethereum.Event {
  get params(): AdapterRemoved__Params {
    return new AdapterRemoved__Params(this);
  }
}

export class AdapterRemoved__Params {
  _event: AdapterRemoved;

  constructor(event: AdapterRemoved) {
    this._event = event;
  }

  get adapterId(): Bytes {
    return this._event.parameters[0].value.toBytes();
  }
}

export class AddressConfigurationUpdated extends ethereum.Event {
  get params(): AddressConfigurationUpdated__Params {
    return new AddressConfigurationUpdated__Params(this);
  }
}

export class AddressConfigurationUpdated__Params {
  _event: AddressConfigurationUpdated;

  constructor(event: AddressConfigurationUpdated) {
    this._event = event;
  }

  get key(): Bytes {
    return this._event.parameters[0].value.toBytes();
  }

  get value(): Address {
    return this._event.parameters[1].value.toAddress();
  }
}

export class ConfigurationUpdated extends ethereum.Event {
  get params(): ConfigurationUpdated__Params {
    return new ConfigurationUpdated__Params(this);
  }
}

export class ConfigurationUpdated__Params {
  _event: ConfigurationUpdated;

  constructor(event: ConfigurationUpdated) {
    this._event = event;
  }

  get key(): Bytes {
    return this._event.parameters[0].value.toBytes();
  }

  get value(): BigInt {
    return this._event.parameters[1].value.toBigInt();
  }
}

export class ExtensionAdded extends ethereum.Event {
  get params(): ExtensionAdded__Params {
    return new ExtensionAdded__Params(this);
  }
}

export class ExtensionAdded__Params {
  _event: ExtensionAdded;

  constructor(event: ExtensionAdded) {
    this._event = event;
  }

  get extensionId(): Bytes {
    return this._event.parameters[0].value.toBytes();
  }

  get extensionAddress(): Address {
    return this._event.parameters[1].value.toAddress();
  }
}

export class ExtensionRemoved extends ethereum.Event {
  get params(): ExtensionRemoved__Params {
    return new ExtensionRemoved__Params(this);
  }
}

export class ExtensionRemoved__Params {
  _event: ExtensionRemoved;

  constructor(event: ExtensionRemoved) {
    this._event = event;
  }

  get extensionId(): Bytes {
    return this._event.parameters[0].value.toBytes();
  }
}

export class MemberJailed extends ethereum.Event {
  get params(): MemberJailed__Params {
    return new MemberJailed__Params(this);
  }
}

export class MemberJailed__Params {
  _event: MemberJailed;

  constructor(event: MemberJailed) {
    this._event = event;
  }

  get memberAddr(): Address {
    return this._event.parameters[0].value.toAddress();
  }
}

export class MemberUnjailed extends ethereum.Event {
  get params(): MemberUnjailed__Params {
    return new MemberUnjailed__Params(this);
  }
}

export class MemberUnjailed__Params {
  _event: MemberUnjailed;

  constructor(event: MemberUnjailed) {
    this._event = event;
  }

  get memberAddr(): Address {
    return this._event.parameters[0].value.toAddress();
  }
}

export class ProcessedProposal extends ethereum.Event {
  get params(): ProcessedProposal__Params {
    return new ProcessedProposal__Params(this);
  }
}

export class ProcessedProposal__Params {
  _event: ProcessedProposal;

  constructor(event: ProcessedProposal) {
    this._event = event;
  }

  get proposalId(): Bytes {
    return this._event.parameters[0].value.toBytes();
  }

  get flags(): BigInt {
    return this._event.parameters[1].value.toBigInt();
  }
}

export class SponsoredProposal extends ethereum.Event {
  get params(): SponsoredProposal__Params {
    return new SponsoredProposal__Params(this);
  }
}

export class SponsoredProposal__Params {
  _event: SponsoredProposal;

  constructor(event: SponsoredProposal) {
    this._event = event;
  }

  get proposalId(): Bytes {
    return this._event.parameters[0].value.toBytes();
  }

  get flags(): BigInt {
    return this._event.parameters[1].value.toBigInt();
  }
}

export class SubmittedProposal extends ethereum.Event {
  get params(): SubmittedProposal__Params {
    return new SubmittedProposal__Params(this);
  }
}

export class SubmittedProposal__Params {
  _event: SubmittedProposal;

  constructor(event: SubmittedProposal) {
    this._event = event;
  }

  get proposalId(): Bytes {
    return this._event.parameters[0].value.toBytes();
  }

  get flags(): BigInt {
    return this._event.parameters[1].value.toBigInt();
  }
}

export class UpdateDelegateKey extends ethereum.Event {
  get params(): UpdateDelegateKey__Params {
    return new UpdateDelegateKey__Params(this);
  }
}

export class UpdateDelegateKey__Params {
  _event: UpdateDelegateKey;

  constructor(event: UpdateDelegateKey) {
    this._event = event;
  }

  get memberAddress(): Address {
    return this._event.parameters[0].value.toAddress();
  }

  get newDelegateKey(): Address {
    return this._event.parameters[1].value.toAddress();
  }
}

export class DaoRegistry__inverseAdaptersResult {
  value0: Bytes;
  value1: BigInt;

  constructor(value0: Bytes, value1: BigInt) {
    this.value0 = value0;
    this.value1 = value1;
  }

  toMap(): TypedMap<string, ethereum.Value> {
    let map = new TypedMap<string, ethereum.Value>();
    map.set("value0", ethereum.Value.fromFixedBytes(this.value0));
    map.set("value1", ethereum.Value.fromUnsignedBigInt(this.value1));
    return map;
  }
}

export class DaoRegistry__proposalsResult {
  value0: Address;
  value1: BigInt;

  constructor(value0: Address, value1: BigInt) {
    this.value0 = value0;
    this.value1 = value1;
  }

  toMap(): TypedMap<string, ethereum.Value> {
    let map = new TypedMap<string, ethereum.Value>();
    map.set("value0", ethereum.Value.fromAddress(this.value0));
    map.set("value1", ethereum.Value.fromUnsignedBigInt(this.value1));
    return map;
  }
}

export class DaoRegistry extends ethereum.SmartContract {
  static bind(address: Address): DaoRegistry {
    return new DaoRegistry("DaoRegistry", address);
  }

  adapters(param0: Bytes): Address {
    let result = super.call("adapters", "adapters(bytes32):(address)", [
      ethereum.Value.fromFixedBytes(param0)
    ]);

    return result[0].toAddress();
  }

  try_adapters(param0: Bytes): ethereum.CallResult<Address> {
    let result = super.tryCall("adapters", "adapters(bytes32):(address)", [
      ethereum.Value.fromFixedBytes(param0)
    ]);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toAddress());
  }

  addressConfiguration(param0: Bytes): Address {
    let result = super.call(
      "addressConfiguration",
      "addressConfiguration(bytes32):(address)",
      [ethereum.Value.fromFixedBytes(param0)]
    );

    return result[0].toAddress();
  }

  try_addressConfiguration(param0: Bytes): ethereum.CallResult<Address> {
    let result = super.tryCall(
      "addressConfiguration",
      "addressConfiguration(bytes32):(address)",
      [ethereum.Value.fromFixedBytes(param0)]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toAddress());
  }

  extensions(param0: Bytes): Address {
    let result = super.call("extensions", "extensions(bytes32):(address)", [
      ethereum.Value.fromFixedBytes(param0)
    ]);

    return result[0].toAddress();
  }

  try_extensions(param0: Bytes): ethereum.CallResult<Address> {
    let result = super.tryCall("extensions", "extensions(bytes32):(address)", [
      ethereum.Value.fromFixedBytes(param0)
    ]);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toAddress());
  }

  getFlag(flags: BigInt, flag: BigInt): boolean {
    let result = super.call("getFlag", "getFlag(uint256,uint256):(bool)", [
      ethereum.Value.fromUnsignedBigInt(flags),
      ethereum.Value.fromUnsignedBigInt(flag)
    ]);

    return result[0].toBoolean();
  }

  try_getFlag(flags: BigInt, flag: BigInt): ethereum.CallResult<boolean> {
    let result = super.tryCall("getFlag", "getFlag(uint256,uint256):(bool)", [
      ethereum.Value.fromUnsignedBigInt(flags),
      ethereum.Value.fromUnsignedBigInt(flag)
    ]);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBoolean());
  }

  initialized(): boolean {
    let result = super.call("initialized", "initialized():(bool)", []);

    return result[0].toBoolean();
  }

  try_initialized(): ethereum.CallResult<boolean> {
    let result = super.tryCall("initialized", "initialized():(bool)", []);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBoolean());
  }

  inverseAdapters(param0: Address): DaoRegistry__inverseAdaptersResult {
    let result = super.call(
      "inverseAdapters",
      "inverseAdapters(address):(bytes32,uint256)",
      [ethereum.Value.fromAddress(param0)]
    );

    return new DaoRegistry__inverseAdaptersResult(
      result[0].toBytes(),
      result[1].toBigInt()
    );
  }

  try_inverseAdapters(
    param0: Address
  ): ethereum.CallResult<DaoRegistry__inverseAdaptersResult> {
    let result = super.tryCall(
      "inverseAdapters",
      "inverseAdapters(address):(bytes32,uint256)",
      [ethereum.Value.fromAddress(param0)]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(
      new DaoRegistry__inverseAdaptersResult(
        value[0].toBytes(),
        value[1].toBigInt()
      )
    );
  }

  inverseExtensions(param0: Address): Bytes {
    let result = super.call(
      "inverseExtensions",
      "inverseExtensions(address):(bytes32)",
      [ethereum.Value.fromAddress(param0)]
    );

    return result[0].toBytes();
  }

  try_inverseExtensions(param0: Address): ethereum.CallResult<Bytes> {
    let result = super.tryCall(
      "inverseExtensions",
      "inverseExtensions(address):(bytes32)",
      [ethereum.Value.fromAddress(param0)]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBytes());
  }

  mainConfiguration(param0: Bytes): BigInt {
    let result = super.call(
      "mainConfiguration",
      "mainConfiguration(bytes32):(uint256)",
      [ethereum.Value.fromFixedBytes(param0)]
    );

    return result[0].toBigInt();
  }

  try_mainConfiguration(param0: Bytes): ethereum.CallResult<BigInt> {
    let result = super.tryCall(
      "mainConfiguration",
      "mainConfiguration(bytes32):(uint256)",
      [ethereum.Value.fromFixedBytes(param0)]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  memberAddressesByDelegatedKey(param0: Address): Address {
    let result = super.call(
      "memberAddressesByDelegatedKey",
      "memberAddressesByDelegatedKey(address):(address)",
      [ethereum.Value.fromAddress(param0)]
    );

    return result[0].toAddress();
  }

  try_memberAddressesByDelegatedKey(
    param0: Address
  ): ethereum.CallResult<Address> {
    let result = super.tryCall(
      "memberAddressesByDelegatedKey",
      "memberAddressesByDelegatedKey(address):(address)",
      [ethereum.Value.fromAddress(param0)]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toAddress());
  }

  members(param0: Address): BigInt {
    let result = super.call("members", "members(address):(uint256)", [
      ethereum.Value.fromAddress(param0)
    ]);

    return result[0].toBigInt();
  }

  try_members(param0: Address): ethereum.CallResult<BigInt> {
    let result = super.tryCall("members", "members(address):(uint256)", [
      ethereum.Value.fromAddress(param0)
    ]);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  proposals(param0: Bytes): DaoRegistry__proposalsResult {
    let result = super.call(
      "proposals",
      "proposals(bytes32):(address,uint256)",
      [ethereum.Value.fromFixedBytes(param0)]
    );

    return new DaoRegistry__proposalsResult(
      result[0].toAddress(),
      result[1].toBigInt()
    );
  }

  try_proposals(
    param0: Bytes
  ): ethereum.CallResult<DaoRegistry__proposalsResult> {
    let result = super.tryCall(
      "proposals",
      "proposals(bytes32):(address,uint256)",
      [ethereum.Value.fromFixedBytes(param0)]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(
      new DaoRegistry__proposalsResult(
        value[0].toAddress(),
        value[1].toBigInt()
      )
    );
  }

  setFlag(flags: BigInt, flag: BigInt, value: boolean): BigInt {
    let result = super.call(
      "setFlag",
      "setFlag(uint256,uint256,bool):(uint256)",
      [
        ethereum.Value.fromUnsignedBigInt(flags),
        ethereum.Value.fromUnsignedBigInt(flag),
        ethereum.Value.fromBoolean(value)
      ]
    );

    return result[0].toBigInt();
  }

  try_setFlag(
    flags: BigInt,
    flag: BigInt,
    value: boolean
  ): ethereum.CallResult<BigInt> {
    let result = super.tryCall(
      "setFlag",
      "setFlag(uint256,uint256,bool):(uint256)",
      [
        ethereum.Value.fromUnsignedBigInt(flags),
        ethereum.Value.fromUnsignedBigInt(flag),
        ethereum.Value.fromBoolean(value)
      ]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  state(): i32 {
    let result = super.call("state", "state():(uint8)", []);

    return result[0].toI32();
  }

  try_state(): ethereum.CallResult<i32> {
    let result = super.tryCall("state", "state():(uint8)", []);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toI32());
  }

  getConfiguration(key: Bytes): BigInt {
    let result = super.call(
      "getConfiguration",
      "getConfiguration(bytes32):(uint256)",
      [ethereum.Value.fromFixedBytes(key)]
    );

    return result[0].toBigInt();
  }

  try_getConfiguration(key: Bytes): ethereum.CallResult<BigInt> {
    let result = super.tryCall(
      "getConfiguration",
      "getConfiguration(bytes32):(uint256)",
      [ethereum.Value.fromFixedBytes(key)]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  getAddressConfiguration(key: Bytes): Address {
    let result = super.call(
      "getAddressConfiguration",
      "getAddressConfiguration(bytes32):(address)",
      [ethereum.Value.fromFixedBytes(key)]
    );

    return result[0].toAddress();
  }

  try_getAddressConfiguration(key: Bytes): ethereum.CallResult<Address> {
    let result = super.tryCall(
      "getAddressConfiguration",
      "getAddressConfiguration(bytes32):(address)",
      [ethereum.Value.fromFixedBytes(key)]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toAddress());
  }

  isExtension(extensionAddr: Address): boolean {
    let result = super.call("isExtension", "isExtension(address):(bool)", [
      ethereum.Value.fromAddress(extensionAddr)
    ]);

    return result[0].toBoolean();
  }

  try_isExtension(extensionAddr: Address): ethereum.CallResult<boolean> {
    let result = super.tryCall("isExtension", "isExtension(address):(bool)", [
      ethereum.Value.fromAddress(extensionAddr)
    ]);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBoolean());
  }

  isAdapter(adapterAddress: Address): boolean {
    let result = super.call("isAdapter", "isAdapter(address):(bool)", [
      ethereum.Value.fromAddress(adapterAddress)
    ]);

    return result[0].toBoolean();
  }

  try_isAdapter(adapterAddress: Address): ethereum.CallResult<boolean> {
    let result = super.tryCall("isAdapter", "isAdapter(address):(bool)", [
      ethereum.Value.fromAddress(adapterAddress)
    ]);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBoolean());
  }

  hasAdapterAccess(adapterAddress: Address, flag: i32): boolean {
    let result = super.call(
      "hasAdapterAccess",
      "hasAdapterAccess(address,uint8):(bool)",
      [
        ethereum.Value.fromAddress(adapterAddress),
        ethereum.Value.fromUnsignedBigInt(BigInt.fromI32(flag))
      ]
    );

    return result[0].toBoolean();
  }

  try_hasAdapterAccess(
    adapterAddress: Address,
    flag: i32
  ): ethereum.CallResult<boolean> {
    let result = super.tryCall(
      "hasAdapterAccess",
      "hasAdapterAccess(address,uint8):(bool)",
      [
        ethereum.Value.fromAddress(adapterAddress),
        ethereum.Value.fromUnsignedBigInt(BigInt.fromI32(flag))
      ]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBoolean());
  }

  hasAdapterAccessToExtension(
    adapterAddress: Address,
    extensionAddress: Address,
    flag: i32
  ): boolean {
    let result = super.call(
      "hasAdapterAccessToExtension",
      "hasAdapterAccessToExtension(address,address,uint8):(bool)",
      [
        ethereum.Value.fromAddress(adapterAddress),
        ethereum.Value.fromAddress(extensionAddress),
        ethereum.Value.fromUnsignedBigInt(BigInt.fromI32(flag))
      ]
    );

    return result[0].toBoolean();
  }

  try_hasAdapterAccessToExtension(
    adapterAddress: Address,
    extensionAddress: Address,
    flag: i32
  ): ethereum.CallResult<boolean> {
    let result = super.tryCall(
      "hasAdapterAccessToExtension",
      "hasAdapterAccessToExtension(address,address,uint8):(bool)",
      [
        ethereum.Value.fromAddress(adapterAddress),
        ethereum.Value.fromAddress(extensionAddress),
        ethereum.Value.fromUnsignedBigInt(BigInt.fromI32(flag))
      ]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBoolean());
  }

  getAdapterAddress(adapterId: Bytes): Address {
    let result = super.call(
      "getAdapterAddress",
      "getAdapterAddress(bytes32):(address)",
      [ethereum.Value.fromFixedBytes(adapterId)]
    );

    return result[0].toAddress();
  }

  try_getAdapterAddress(adapterId: Bytes): ethereum.CallResult<Address> {
    let result = super.tryCall(
      "getAdapterAddress",
      "getAdapterAddress(bytes32):(address)",
      [ethereum.Value.fromFixedBytes(adapterId)]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toAddress());
  }

  getExtensionAddress(extensionId: Bytes): Address {
    let result = super.call(
      "getExtensionAddress",
      "getExtensionAddress(bytes32):(address)",
      [ethereum.Value.fromFixedBytes(extensionId)]
    );

    return result[0].toAddress();
  }

  try_getExtensionAddress(extensionId: Bytes): ethereum.CallResult<Address> {
    let result = super.tryCall(
      "getExtensionAddress",
      "getExtensionAddress(bytes32):(address)",
      [ethereum.Value.fromFixedBytes(extensionId)]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toAddress());
  }

  isActiveMember(addr: Address): boolean {
    let result = super.call(
      "isActiveMember",
      "isActiveMember(address):(bool)",
      [ethereum.Value.fromAddress(addr)]
    );

    return result[0].toBoolean();
  }

  try_isActiveMember(addr: Address): ethereum.CallResult<boolean> {
    let result = super.tryCall(
      "isActiveMember",
      "isActiveMember(address):(bool)",
      [ethereum.Value.fromAddress(addr)]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBoolean());
  }

  getProposalFlag(proposalId: Bytes, flag: i32): boolean {
    let result = super.call(
      "getProposalFlag",
      "getProposalFlag(bytes32,uint8):(bool)",
      [
        ethereum.Value.fromFixedBytes(proposalId),
        ethereum.Value.fromUnsignedBigInt(BigInt.fromI32(flag))
      ]
    );

    return result[0].toBoolean();
  }

  try_getProposalFlag(
    proposalId: Bytes,
    flag: i32
  ): ethereum.CallResult<boolean> {
    let result = super.tryCall(
      "getProposalFlag",
      "getProposalFlag(bytes32,uint8):(bool)",
      [
        ethereum.Value.fromFixedBytes(proposalId),
        ethereum.Value.fromUnsignedBigInt(BigInt.fromI32(flag))
      ]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBoolean());
  }

  getMemberFlag(memberAddress: Address, flag: i32): boolean {
    let result = super.call(
      "getMemberFlag",
      "getMemberFlag(address,uint8):(bool)",
      [
        ethereum.Value.fromAddress(memberAddress),
        ethereum.Value.fromUnsignedBigInt(BigInt.fromI32(flag))
      ]
    );

    return result[0].toBoolean();
  }

  try_getMemberFlag(
    memberAddress: Address,
    flag: i32
  ): ethereum.CallResult<boolean> {
    let result = super.tryCall(
      "getMemberFlag",
      "getMemberFlag(address,uint8):(bool)",
      [
        ethereum.Value.fromAddress(memberAddress),
        ethereum.Value.fromUnsignedBigInt(BigInt.fromI32(flag))
      ]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBoolean());
  }

  getNbMembers(): BigInt {
    let result = super.call("getNbMembers", "getNbMembers():(uint256)", []);

    return result[0].toBigInt();
  }

  try_getNbMembers(): ethereum.CallResult<BigInt> {
    let result = super.tryCall("getNbMembers", "getNbMembers():(uint256)", []);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  getMemberAddress(index: BigInt): Address {
    let result = super.call(
      "getMemberAddress",
      "getMemberAddress(uint256):(address)",
      [ethereum.Value.fromUnsignedBigInt(index)]
    );

    return result[0].toAddress();
  }

  try_getMemberAddress(index: BigInt): ethereum.CallResult<Address> {
    let result = super.tryCall(
      "getMemberAddress",
      "getMemberAddress(uint256):(address)",
      [ethereum.Value.fromUnsignedBigInt(index)]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toAddress());
  }

  isNotReservedAddress(applicant: Address): boolean {
    let result = super.call(
      "isNotReservedAddress",
      "isNotReservedAddress(address):(bool)",
      [ethereum.Value.fromAddress(applicant)]
    );

    return result[0].toBoolean();
  }

  try_isNotReservedAddress(applicant: Address): ethereum.CallResult<boolean> {
    let result = super.tryCall(
      "isNotReservedAddress",
      "isNotReservedAddress(address):(bool)",
      [ethereum.Value.fromAddress(applicant)]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBoolean());
  }

  getAddressIfDelegated(checkAddr: Address): Address {
    let result = super.call(
      "getAddressIfDelegated",
      "getAddressIfDelegated(address):(address)",
      [ethereum.Value.fromAddress(checkAddr)]
    );

    return result[0].toAddress();
  }

  try_getAddressIfDelegated(checkAddr: Address): ethereum.CallResult<Address> {
    let result = super.tryCall(
      "getAddressIfDelegated",
      "getAddressIfDelegated(address):(address)",
      [ethereum.Value.fromAddress(checkAddr)]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toAddress());
  }

  getCurrentDelegateKey(memberAddr: Address): Address {
    let result = super.call(
      "getCurrentDelegateKey",
      "getCurrentDelegateKey(address):(address)",
      [ethereum.Value.fromAddress(memberAddr)]
    );

    return result[0].toAddress();
  }

  try_getCurrentDelegateKey(memberAddr: Address): ethereum.CallResult<Address> {
    let result = super.tryCall(
      "getCurrentDelegateKey",
      "getCurrentDelegateKey(address):(address)",
      [ethereum.Value.fromAddress(memberAddr)]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toAddress());
  }

  getPreviousDelegateKey(memberAddr: Address): Address {
    let result = super.call(
      "getPreviousDelegateKey",
      "getPreviousDelegateKey(address):(address)",
      [ethereum.Value.fromAddress(memberAddr)]
    );

    return result[0].toAddress();
  }

  try_getPreviousDelegateKey(
    memberAddr: Address
  ): ethereum.CallResult<Address> {
    let result = super.tryCall(
      "getPreviousDelegateKey",
      "getPreviousDelegateKey(address):(address)",
      [ethereum.Value.fromAddress(memberAddr)]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toAddress());
  }

  getPriorDelegateKey(memberAddr: Address, blockNumber: BigInt): Address {
    let result = super.call(
      "getPriorDelegateKey",
      "getPriorDelegateKey(address,uint256):(address)",
      [
        ethereum.Value.fromAddress(memberAddr),
        ethereum.Value.fromUnsignedBigInt(blockNumber)
      ]
    );

    return result[0].toAddress();
  }

  try_getPriorDelegateKey(
    memberAddr: Address,
    blockNumber: BigInt
  ): ethereum.CallResult<Address> {
    let result = super.tryCall(
      "getPriorDelegateKey",
      "getPriorDelegateKey(address,uint256):(address)",
      [
        ethereum.Value.fromAddress(memberAddr),
        ethereum.Value.fromUnsignedBigInt(blockNumber)
      ]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toAddress());
  }
}

export class InitializeCall extends ethereum.Call {
  get inputs(): InitializeCall__Inputs {
    return new InitializeCall__Inputs(this);
  }

  get outputs(): InitializeCall__Outputs {
    return new InitializeCall__Outputs(this);
  }
}

export class InitializeCall__Inputs {
  _call: InitializeCall;

  constructor(call: InitializeCall) {
    this._call = call;
  }

  get creator(): Address {
    return this._call.inputValues[0].value.toAddress();
  }

  get payer(): Address {
    return this._call.inputValues[1].value.toAddress();
  }
}

export class InitializeCall__Outputs {
  _call: InitializeCall;

  constructor(call: InitializeCall) {
    this._call = call;
  }
}

export class FinalizeDaoCall extends ethereum.Call {
  get inputs(): FinalizeDaoCall__Inputs {
    return new FinalizeDaoCall__Inputs(this);
  }

  get outputs(): FinalizeDaoCall__Outputs {
    return new FinalizeDaoCall__Outputs(this);
  }
}

export class FinalizeDaoCall__Inputs {
  _call: FinalizeDaoCall;

  constructor(call: FinalizeDaoCall) {
    this._call = call;
  }
}

export class FinalizeDaoCall__Outputs {
  _call: FinalizeDaoCall;

  constructor(call: FinalizeDaoCall) {
    this._call = call;
  }
}

export class SetConfigurationCall extends ethereum.Call {
  get inputs(): SetConfigurationCall__Inputs {
    return new SetConfigurationCall__Inputs(this);
  }

  get outputs(): SetConfigurationCall__Outputs {
    return new SetConfigurationCall__Outputs(this);
  }
}

export class SetConfigurationCall__Inputs {
  _call: SetConfigurationCall;

  constructor(call: SetConfigurationCall) {
    this._call = call;
  }

  get key(): Bytes {
    return this._call.inputValues[0].value.toBytes();
  }

  get value(): BigInt {
    return this._call.inputValues[1].value.toBigInt();
  }
}

export class SetConfigurationCall__Outputs {
  _call: SetConfigurationCall;

  constructor(call: SetConfigurationCall) {
    this._call = call;
  }
}

export class PotentialNewMemberCall extends ethereum.Call {
  get inputs(): PotentialNewMemberCall__Inputs {
    return new PotentialNewMemberCall__Inputs(this);
  }

  get outputs(): PotentialNewMemberCall__Outputs {
    return new PotentialNewMemberCall__Outputs(this);
  }
}

export class PotentialNewMemberCall__Inputs {
  _call: PotentialNewMemberCall;

  constructor(call: PotentialNewMemberCall) {
    this._call = call;
  }

  get memberAddress(): Address {
    return this._call.inputValues[0].value.toAddress();
  }
}

export class PotentialNewMemberCall__Outputs {
  _call: PotentialNewMemberCall;

  constructor(call: PotentialNewMemberCall) {
    this._call = call;
  }
}

export class SetAddressConfigurationCall extends ethereum.Call {
  get inputs(): SetAddressConfigurationCall__Inputs {
    return new SetAddressConfigurationCall__Inputs(this);
  }

  get outputs(): SetAddressConfigurationCall__Outputs {
    return new SetAddressConfigurationCall__Outputs(this);
  }
}

export class SetAddressConfigurationCall__Inputs {
  _call: SetAddressConfigurationCall;

  constructor(call: SetAddressConfigurationCall) {
    this._call = call;
  }

  get key(): Bytes {
    return this._call.inputValues[0].value.toBytes();
  }

  get value(): Address {
    return this._call.inputValues[1].value.toAddress();
  }
}

export class SetAddressConfigurationCall__Outputs {
  _call: SetAddressConfigurationCall;

  constructor(call: SetAddressConfigurationCall) {
    this._call = call;
  }
}

export class AddExtensionCall extends ethereum.Call {
  get inputs(): AddExtensionCall__Inputs {
    return new AddExtensionCall__Inputs(this);
  }

  get outputs(): AddExtensionCall__Outputs {
    return new AddExtensionCall__Outputs(this);
  }
}

export class AddExtensionCall__Inputs {
  _call: AddExtensionCall;

  constructor(call: AddExtensionCall) {
    this._call = call;
  }

  get extensionId(): Bytes {
    return this._call.inputValues[0].value.toBytes();
  }

  get extension(): Address {
    return this._call.inputValues[1].value.toAddress();
  }

  get creator(): Address {
    return this._call.inputValues[2].value.toAddress();
  }
}

export class AddExtensionCall__Outputs {
  _call: AddExtensionCall;

  constructor(call: AddExtensionCall) {
    this._call = call;
  }
}

export class AddAdapterCall extends ethereum.Call {
  get inputs(): AddAdapterCall__Inputs {
    return new AddAdapterCall__Inputs(this);
  }

  get outputs(): AddAdapterCall__Outputs {
    return new AddAdapterCall__Outputs(this);
  }
}

export class AddAdapterCall__Inputs {
  _call: AddAdapterCall;

  constructor(call: AddAdapterCall) {
    this._call = call;
  }

  get adapterId(): Bytes {
    return this._call.inputValues[0].value.toBytes();
  }

  get adapterAddress(): Address {
    return this._call.inputValues[1].value.toAddress();
  }

  get acl(): BigInt {
    return this._call.inputValues[2].value.toBigInt();
  }
}

export class AddAdapterCall__Outputs {
  _call: AddAdapterCall;

  constructor(call: AddAdapterCall) {
    this._call = call;
  }
}

export class SetAclToExtensionForAdapterCall extends ethereum.Call {
  get inputs(): SetAclToExtensionForAdapterCall__Inputs {
    return new SetAclToExtensionForAdapterCall__Inputs(this);
  }

  get outputs(): SetAclToExtensionForAdapterCall__Outputs {
    return new SetAclToExtensionForAdapterCall__Outputs(this);
  }
}

export class SetAclToExtensionForAdapterCall__Inputs {
  _call: SetAclToExtensionForAdapterCall;

  constructor(call: SetAclToExtensionForAdapterCall) {
    this._call = call;
  }

  get extensionAddress(): Address {
    return this._call.inputValues[0].value.toAddress();
  }

  get adapterAddress(): Address {
    return this._call.inputValues[1].value.toAddress();
  }

  get acl(): BigInt {
    return this._call.inputValues[2].value.toBigInt();
  }
}

export class SetAclToExtensionForAdapterCall__Outputs {
  _call: SetAclToExtensionForAdapterCall;

  constructor(call: SetAclToExtensionForAdapterCall) {
    this._call = call;
  }
}

export class RemoveAdapterCall extends ethereum.Call {
  get inputs(): RemoveAdapterCall__Inputs {
    return new RemoveAdapterCall__Inputs(this);
  }

  get outputs(): RemoveAdapterCall__Outputs {
    return new RemoveAdapterCall__Outputs(this);
  }
}

export class RemoveAdapterCall__Inputs {
  _call: RemoveAdapterCall;

  constructor(call: RemoveAdapterCall) {
    this._call = call;
  }

  get adapterId(): Bytes {
    return this._call.inputValues[0].value.toBytes();
  }
}

export class RemoveAdapterCall__Outputs {
  _call: RemoveAdapterCall;

  constructor(call: RemoveAdapterCall) {
    this._call = call;
  }
}

export class RemoveExtensionCall extends ethereum.Call {
  get inputs(): RemoveExtensionCall__Inputs {
    return new RemoveExtensionCall__Inputs(this);
  }

  get outputs(): RemoveExtensionCall__Outputs {
    return new RemoveExtensionCall__Outputs(this);
  }
}

export class RemoveExtensionCall__Inputs {
  _call: RemoveExtensionCall;

  constructor(call: RemoveExtensionCall) {
    this._call = call;
  }

  get extensionId(): Bytes {
    return this._call.inputValues[0].value.toBytes();
  }
}

export class RemoveExtensionCall__Outputs {
  _call: RemoveExtensionCall;

  constructor(call: RemoveExtensionCall) {
    this._call = call;
  }
}

export class JailMemberCall extends ethereum.Call {
  get inputs(): JailMemberCall__Inputs {
    return new JailMemberCall__Inputs(this);
  }

  get outputs(): JailMemberCall__Outputs {
    return new JailMemberCall__Outputs(this);
  }
}

export class JailMemberCall__Inputs {
  _call: JailMemberCall;

  constructor(call: JailMemberCall) {
    this._call = call;
  }

  get memberAddr(): Address {
    return this._call.inputValues[0].value.toAddress();
  }
}

export class JailMemberCall__Outputs {
  _call: JailMemberCall;

  constructor(call: JailMemberCall) {
    this._call = call;
  }
}

export class UnjailMemberCall extends ethereum.Call {
  get inputs(): UnjailMemberCall__Inputs {
    return new UnjailMemberCall__Inputs(this);
  }

  get outputs(): UnjailMemberCall__Outputs {
    return new UnjailMemberCall__Outputs(this);
  }
}

export class UnjailMemberCall__Inputs {
  _call: UnjailMemberCall;

  constructor(call: UnjailMemberCall) {
    this._call = call;
  }

  get memberAddr(): Address {
    return this._call.inputValues[0].value.toAddress();
  }
}

export class UnjailMemberCall__Outputs {
  _call: UnjailMemberCall;

  constructor(call: UnjailMemberCall) {
    this._call = call;
  }
}

export class SubmitProposalCall extends ethereum.Call {
  get inputs(): SubmitProposalCall__Inputs {
    return new SubmitProposalCall__Inputs(this);
  }

  get outputs(): SubmitProposalCall__Outputs {
    return new SubmitProposalCall__Outputs(this);
  }
}

export class SubmitProposalCall__Inputs {
  _call: SubmitProposalCall;

  constructor(call: SubmitProposalCall) {
    this._call = call;
  }

  get proposalId(): Bytes {
    return this._call.inputValues[0].value.toBytes();
  }
}

export class SubmitProposalCall__Outputs {
  _call: SubmitProposalCall;

  constructor(call: SubmitProposalCall) {
    this._call = call;
  }
}

export class SponsorProposalCall extends ethereum.Call {
  get inputs(): SponsorProposalCall__Inputs {
    return new SponsorProposalCall__Inputs(this);
  }

  get outputs(): SponsorProposalCall__Outputs {
    return new SponsorProposalCall__Outputs(this);
  }
}

export class SponsorProposalCall__Inputs {
  _call: SponsorProposalCall;

  constructor(call: SponsorProposalCall) {
    this._call = call;
  }

  get proposalId(): Bytes {
    return this._call.inputValues[0].value.toBytes();
  }

  get sponsoringMember(): Address {
    return this._call.inputValues[1].value.toAddress();
  }
}

export class SponsorProposalCall__Outputs {
  _call: SponsorProposalCall;

  constructor(call: SponsorProposalCall) {
    this._call = call;
  }
}

export class ProcessProposalCall extends ethereum.Call {
  get inputs(): ProcessProposalCall__Inputs {
    return new ProcessProposalCall__Inputs(this);
  }

  get outputs(): ProcessProposalCall__Outputs {
    return new ProcessProposalCall__Outputs(this);
  }
}

export class ProcessProposalCall__Inputs {
  _call: ProcessProposalCall;

  constructor(call: ProcessProposalCall) {
    this._call = call;
  }

  get proposalId(): Bytes {
    return this._call.inputValues[0].value.toBytes();
  }
}

export class ProcessProposalCall__Outputs {
  _call: ProcessProposalCall;

  constructor(call: ProcessProposalCall) {
    this._call = call;
  }
}

export class UpdateDelegateKeyCall extends ethereum.Call {
  get inputs(): UpdateDelegateKeyCall__Inputs {
    return new UpdateDelegateKeyCall__Inputs(this);
  }

  get outputs(): UpdateDelegateKeyCall__Outputs {
    return new UpdateDelegateKeyCall__Outputs(this);
  }
}

export class UpdateDelegateKeyCall__Inputs {
  _call: UpdateDelegateKeyCall;

  constructor(call: UpdateDelegateKeyCall) {
    this._call = call;
  }

  get memberAddr(): Address {
    return this._call.inputValues[0].value.toAddress();
  }

  get newDelegateKey(): Address {
    return this._call.inputValues[1].value.toAddress();
  }
}

export class UpdateDelegateKeyCall__Outputs {
  _call: UpdateDelegateKeyCall;

  constructor(call: UpdateDelegateKeyCall) {
    this._call = call;
  }
}
